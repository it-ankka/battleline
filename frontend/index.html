<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HTTP + WebSocket Boilerplate</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,'Helvetica Neue',Arial;margin:20px;background:#f7f8fa}
    .card{background:#fff;border-radius:8px;padding:16px;margin-bottom:12px;box-shadow:0 1px 4px rgba(0,0,0,.08)}
    label{display:block;margin-bottom:6px;font-weight:600}
    input[type=text], textarea, select{width:100%;padding:8px;border:1px solid #dcdfe6;border-radius:6px}
    button{padding:8px 12px;border-radius:6px;border:0;background:#0366d6;color:#fff;cursor:pointer}
    button.secondary{background:#5a6b84}
    .muted{color:#6b7280;font-size:13px}
    .row{display:flex;gap:8px}
    .log{height:180px;overflow:auto;background:#0f1724;color:#e6eef6;padding:8px;border-radius:6px;font-family:monospace}
    .status{display:inline-block;padding:4px 8px;border-radius:999px;font-weight:700}
    .status.disconnected{background:#fee2e2;color:#9b1c1c}
    .status.connected{background:#dcfce7;color:#166534}
  </style>
</head>
<body>
  <h1>HTTP + WebSocket Boilerplate</h1>
  <p class="muted">A minimal client showing how to call an HTTP endpoint (fetch) and open a WebSocket, then send data over it.</p>

  <section class="card" id="httpCard">
    <h2>HTTP request</h2>
    <label for="httpUrl">Endpoint URL</label>
    <input id="httpUrl" type="text" placeholder="https://api.example.com/data" value="https://httpbin.org/post" />

    <label for="httpMethod">Method</label>
    <select id="httpMethod">
      <option>GET</option>
      <option selected>POST</option>
      <option>PUT</option>
      <option>DELETE</option>
    </select>

    <label for="httpBody">JSON body (for POST/PUT)</label>
    <textarea id="httpBody" rows="6">{"message":"hello from client"}</textarea>

    <div class="row" style="margin-top:8px">
      <button id="sendHttp">Send HTTP Request</button>
      <button id="clearHttp" class="secondary">Clear Response</button>
    </div>

    <h3>Response</h3>
    <pre id="httpResponse" class="log"></pre>
  </section>

  <section class="card" id="wsCard">
    <h2>WebSocket</h2>
    <label for="wsUrl">WebSocket URL</label>
    <input id="wsUrl" type="text" placeholder="wss://example.com/socket" value="wss://echo.websocket.org" />

    <div style="margin-top:8px" class="row">
      <button id="connectWs">Connect</button>
      <button id="disconnectWs" class="secondary">Disconnect</button>
      <div id="wsStatus" style="margin-left:auto"><span class="status disconnected">DISCONNECTED</span></div>
    </div>

    <label for="wsSend">Message to send</label>
    <input id="wsSend" type="text" placeholder='{"type":"greeting","payload":"hi"}' />
    <div class="row" style="margin-top:8px">
      <button id="sendWs">Send over WebSocket</button>
      <button id="clearLog" class="secondary">Clear Log</button>
    </div>

    <h3>Log</h3>
    <div id="wsLog" class="log"></div>
  </section>

  <script>
    // ---------- Utilities ----------
    const el = id => document.getElementById(id);
    const safeJsonParse = str => {
      try { return JSON.parse(str); } catch(e) { return null; }
    };

    // ---------- HTTP (fetch) ----------
    async function sendHttpRequest(){
      const url = el('httpUrl').value.trim();
      const method = el('httpMethod').value;
      const rawBody = el('httpBody').value.trim();

      if(!url){ el('httpResponse').textContent = 'Please provide a URL.'; return; }

      const options = { method, headers: {} };
      if(method === 'POST' || method === 'PUT'){
        // attempt to parse JSON; if invalid, send as text
        const json = safeJsonParse(rawBody);
        if(json !== null){ options.body = JSON.stringify(json); options.headers['Content-Type'] = 'application/json'; }
        else { options.body = rawBody; options.headers['Content-Type'] = 'text/plain'; }
      }

      el('httpResponse').textContent = 'Sending...';
      try{
        const res = await fetch(url, options);
        const contentType = res.headers.get('content-type') || '';
        let bodyText;
        if(contentType.includes('application/json')){
          const data = await res.json();
          bodyText = JSON.stringify(data, null, 2);
        } else {
          bodyText = await res.text();
        }
        el('httpResponse').textContent = `HTTP ${res.status} ${res.statusText}\n\n` + bodyText;
      }catch(err){
        el('httpResponse').textContent = 'Request failed: ' + (err.message || String(err));
      }
    }

    el('sendHttp').addEventListener('click', sendHttpRequest);
    el('clearHttp').addEventListener('click', () => el('httpResponse').textContent = '');

    // ---------- WebSocket ----------
    let socket = null;
    let reconnectAttempts = 0;
    let manualClose = false;

    function setWsStatus(connected){
      const status = el('wsStatus').querySelector('.status');
      if(connected){ status.textContent = 'CONNECTED'; status.className = 'status connected'; }
      else { status.textContent = 'DISCONNECTED'; status.className = 'status disconnected'; }
    }

    function logWs(...parts){
      const log = el('wsLog');
      const ts = new Date().toISOString();
      log.textContent = `${ts} â€” ${parts.map(p => (typeof p === 'string' ? p : JSON.stringify(p))).join(' ')}\n` + log.textContent;
    }

    function connectWebSocket(){
      const url = el('wsUrl').value.trim();
      if(!url){ alert('Please provide a WebSocket URL'); return; }

      manualClose = false;
      if(socket && socket.readyState === WebSocket.OPEN) return;

      try{
        socket = new WebSocket(url);
      }catch(err){
        logWs('WebSocket constructor failed:', err.message || err);
        return;
      }

      setWsStatus(false);
      logWs('Connecting to', url);

      socket.addEventListener('open', () => {
        reconnectAttempts = 0;
        setWsStatus(true);
        logWs('OPEN');
      });

      socket.addEventListener('message', ev => {
        // if message is binary, try to read as blob
        if(typeof ev.data === 'string'){
          let parsed = safeJsonParse(ev.data);
          logWs('RECEIVED', parsed !== null ? parsed : ev.data);
        } else {
          // handle Blob/ArrayBuffer
          logWs('RECEIVED binary data (Blob/ArrayBuffer)');
          // optionally: read blob as text
          if(ev.data instanceof Blob){
            ev.data.text().then(t => logWs('binary text:', t));
          }
        }
      });

      socket.addEventListener('close', ev => {
        setWsStatus(false);
        logWs('CLOSED', `code=${ev.code}`, `reason=${ev.reason || ''}`);
        socket = null;
        if(!manualClose){
          // simple reconnect strategy with cap
          reconnectAttempts++;
          const delay = Math.min(10000, 500 * Math.pow(2, reconnectAttempts));
          logWs('Reconnecting in', delay + 'ms');
          setTimeout(() => connectWebSocket(), delay);
        }
      });

      socket.addEventListener('error', err => {
        logWs('ERROR', err instanceof Event ? 'see console' : err);
        console.error('WebSocket error:', err);
      });
    }

    function disconnectWebSocket(){
      if(!socket) return; manualClose = true;
      socket.close(1000, 'Client requested close');
      setWsStatus(false);
      logWs('Manual disconnect requested');
    }

    function sendWsMessage(){
      const msg = el('wsSend').value;
      if(!socket || socket.readyState !== WebSocket.OPEN){ alert('WebSocket is not open'); return; }

      // try to send JSON if text looks like JSON
      const parsed = safeJsonParse(msg);
      try{
        socket.send(parsed !== null ? JSON.stringify(parsed) : msg);
        logWs('SENT', parsed !== null ? parsed : msg);
      }catch(err){
        logWs('Failed to send:', err.message || err);
      }
    }

    el('connectWs').addEventListener('click', connectWebSocket);
    el('disconnectWs').addEventListener('click', disconnectWebSocket);
    el('sendWs').addEventListener('click', sendWsMessage);
    el('clearLog').addEventListener('click', () => el('wsLog').textContent = '');

    // allow pressing Enter in message input to send
    el('wsSend').addEventListener('keydown', e => { if(e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); sendWsMessage(); } });

    // populate example URLs for convenience (these can be changed by the user)
    // NOTE: echo.websocket.org used to be a public echo service; replace with your own server in production.

    // ---------- Helpful example: call endpoint then send websocket message ----------
    // If you'd like to perform a HTTP call first then send the result over an established WebSocket,
    // here's a small helper that chains them. It will: 1) call the HTTP endpoint, 2) connect WS if needed, 3) send the HTTP response body over WS.
    async function callHttpThenSendOverWs(){
      const url = el('httpUrl').value.trim();
      if(!url) return alert('Provide HTTP URL first');

      // 1) call http
      try{
        const res = await fetch(url, { method: el('httpMethod').value, headers: {'Content-Type':'application/json'}, body: el('httpBody').value });
        let text;
        const ct = res.headers.get('content-type') || '';
        if(ct.includes('application/json')) text = JSON.stringify(await res.json()); else text = await res.text();

        // 2) ensure websocket is connected
        if(!socket || socket.readyState !== WebSocket.OPEN){
          // connect and wait for open
          const wsUrl = el('wsUrl').value.trim();
          if(!wsUrl) return alert('Provide WebSocket URL to send the HTTP response to.');

          // create a promise that resolves once socket opens or rejects after timeout
          await new Promise((resolve, reject) => {
            manualClose = false;
            socket = new WebSocket(wsUrl);
            const timeout = setTimeout(() => reject(new Error('WebSocket open timeout')), 5000);
            socket.addEventListener('open', () => { clearTimeout(timeout); setWsStatus(true); resolve(); });
            socket.addEventListener('error', e => { clearTimeout(timeout); reject(e); });
            socket.addEventListener('close', () => { clearTimeout(timeout); reject(new Error('Socket closed before open')); });
            socket.addEventListener('message', ev => { if(typeof ev.data === 'string') logWs('RECEIVED (during chain)', safeJsonParse(ev.data) || ev.data); else logWs('RECEIVED binary (during chain)'); });
          }).catch(err => { logWs('Failed to connect WS for chaining:', err.message || err); throw err; });
        }

        // 3) send the data
        socket.send(text);
        logWs('SENT (chained HTTP->WS)', text);
      }catch(err){
        logWs('Error in callHttpThenSendOverWs:', err.message || err);
      }
    }

    // Example hotkey: Ctrl+Alt+S to run the chain
    document.addEventListener('keydown', e => { if(e.ctrlKey && e.altKey && e.key.toLowerCase() === 's'){ callHttpThenSendOverWs(); } });

    // Expose helpers for console debugging
    window.__dev = { connectWebSocket, disconnectWebSocket, sendWsMessage, sendHttpRequest, callHttpThenSendOverWs };
  </script>
</body>
</html>

